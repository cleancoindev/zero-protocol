{
  "address": "0xE6E340D132b5f46d1e472DebcD681B2aBc16e57E",
  "abi": [],
  "transactionHash": "0x8fa04a713d550d3444e7e9cf1c0712805945df40309d5fdf5e822b47c8466a64",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xE6E340D132b5f46d1e472DebcD681B2aBc16e57E",
    "transactionIndex": 0,
    "gasUsed": "130636",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x91281b7910cc349304861d2bdc7f1282d9b79c7223b6b79ec2193a5315809f9e",
    "transactionHash": "0x8fa04a713d550d3444e7e9cf1c0712805945df40309d5fdf5e822b47c8466a64",
    "logs": [],
    "blockNumber": 12555983,
    "cumulativeGasUsed": "130636",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "7c916b99c4e0e66925fbc62b1cc3403a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.5+commit.a4f2e591\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"deploy(address,bytes32)\":{\"params\":{\"implementation\":\"Address of implementation\",\"salt\":\"Salt to use\"},\"returns\":{\"cloneAddress\":\"Address of the created clone contract.\"}}},\"title\":\"clone factory library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deploy(address,bytes32)\":{\"notice\":\"Deploys a given master Contract as a clone. Any ETH transferred with this call is forwarded to the new clone. Emits `LogDeploy`.\"}},\"notice\":\"deploys implementation or clones\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/factory/FactoryLib.sol\":\"FactoryLib\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/libraries/factory/FactoryLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\nimport {Implementation} from \\\"./Implementation.sol\\\";\\nimport {Create2} from \\\"oz410/utils/Create2.sol\\\";\\n\\n/**\\n@title clone factory library\\n@notice deploys implementation or clones\\n*/\\nlibrary FactoryLib {\\n    function assembleCreationCode(address implementation)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        result = new bytes(0x37);\\n        bytes20 targetBytes = bytes20(implementation);\\n        assembly {\\n            let clone := add(result, 0x20)\\n            mstore(\\n                clone,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n            mstore(add(clone, 0x14), targetBytes)\\n            mstore(\\n                add(clone, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    function computeAddress(\\n        address creator,\\n        address implementation,\\n        bytes32 salt\\n    ) internal pure returns (address result) {\\n        result = Create2.computeAddress(\\n\\t    salt,\\n\\t    keccak256(assembleCreationCode(implementation)),\\n            creator\\n        );\\n    }\\n    function computeImplementationAddress(\\n      address creator,\\n      bytes32 bytecodeHash,\\n      string memory id\\n    ) internal pure returns (address result) {\\n      result = Create2.computeAddress(\\n        keccak256(abi.encodePacked(id)),\\n\\tbytecodeHash,\\n\\tcreator\\n      );\\n    }\\n\\n    /// @notice Deploys a given master Contract as a clone.\\n    /// Any ETH transferred with this call is forwarded to the new clone.\\n    /// Emits `LogDeploy`.\\n    /// @param implementation Address of implementation\\n    /// @param salt Salt to use\\n    /// @return cloneAddress Address of the created clone contract.\\n    function deploy(address implementation, bytes32 salt)\\n        public\\n        returns (address cloneAddress)\\n    {\\n        bytes memory creationCode = assembleCreationCode(implementation);\\n        assembly {\\n            cloneAddress := create2(0, add(0x20, creationCode), 0x37, salt)\\n        }\\n    }\\n\\n    function deployImplementation(bytes memory creationCode, string memory id)\\n        internal\\n        returns (address implementation)\\n    {\\n        bytes32 salt = keccak256(abi.encodePacked(id));\\n        assembly {\\n            implementation := create2(\\n                0,\\n                add(0x20, creationCode),\\n                mload(creationCode),\\n                salt\\n            )\\n        }\\n        Implementation(implementation).lock();\\n    }\\n}\\n\",\"keccak256\":\"0xedd96b4f23353b83cb236516f3c991e74f7c74fa245c3ad026c34da94e032bf0\",\"license\":\"MIT\"},\"contracts/libraries/factory/Implementation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\nimport {Initializable} from \\\"oz410/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n@title must be inherited by a contract that will be deployed with ZeroFactoryLib\\n@author raymondpulver\\n*/\\nabstract contract Implementation is Initializable {\\n    /**\\n  @notice ensure the contract cannot be initialized twice\\n  */\\n    function lock() public virtual initializer {\\n        // no other logic\\n    }\\n}\\n\",\"keccak256\":\"0x70f12691ff3c27ad36b480f2ddd4a9c17a1e957d19ba9466b34814ea72bba3f2\",\"license\":\"MIT\"},\"oz410/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x67d2f282a9678e58e878a0b774041ba7a01e2740a262aea97a3f681339914713\",\"license\":\"MIT\"},\"oz410/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\",\"keccak256\":\"0xf35335925904418fa03f87f35feddc196c7fd2b4d6397a1c45c427085cee3707\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61016561003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c806332c02a141461003a575b600080fd5b81801561004657600080fd5b5061005a6100553660046100f7565b610076565b6040516001600160a01b03909116815260200160405180910390f35b60008061008284610096565b9050826037826020016000f5949350505050565b60408051603780825260608281019093526020820181803683375050733d602d80600a3d3981f3363d3d373d3d3d363d7360601b60208301525060609290921b6034830152506e5af43d82803e903d91602b57fd5bf360881b604882015290565b6000806040838503121561010a57600080fd5b82356001600160a01b038116811461012157600080fd5b94602093909301359350505056fea26469706673582212206519674c958bc550dde1b9e9432c37484ee2efee7c4a9b57c7edf3e69375812964736f6c63430008050033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c806332c02a141461003a575b600080fd5b81801561004657600080fd5b5061005a6100553660046100f7565b610076565b6040516001600160a01b03909116815260200160405180910390f35b60008061008284610096565b9050826037826020016000f5949350505050565b60408051603780825260608281019093526020820181803683375050733d602d80600a3d3981f3363d3d373d3d3d363d7360601b60208301525060609290921b6034830152506e5af43d82803e903d91602b57fd5bf360881b604882015290565b6000806040838503121561010a57600080fd5b82356001600160a01b038116811461012157600080fd5b94602093909301359350505056fea26469706673582212206519674c958bc550dde1b9e9432c37484ee2efee7c4a9b57c7edf3e69375812964736f6c63430008050033",
  "libraries": {},
  "devdoc": {
    "kind": "dev",
    "methods": {
      "deploy(address,bytes32)": {
        "params": {
          "implementation": "Address of implementation",
          "salt": "Salt to use"
        },
        "returns": {
          "cloneAddress": "Address of the created clone contract."
        }
      }
    },
    "title": "clone factory library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "deploy(address,bytes32)": {
        "notice": "Deploys a given master Contract as a clone. Any ETH transferred with this call is forwarded to the new clone. Emits `LogDeploy`."
      }
    },
    "notice": "deploys implementation or clones",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}